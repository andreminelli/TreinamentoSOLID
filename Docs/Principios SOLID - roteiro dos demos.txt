!!!!!---- SEMPRE EXECUTAR O BRANCH PARA MOSTRAR QUE FUNCIONA ----!!!!!

master -> projeto base, somente com Main

SRP-0 -> extraido EtlProcessor do Main

SRP-1 -> extraido CsvAccountExtractor do EtlProcessor

SRP-2 -> extraido SqlAccountLoading do EtlProcessor

OCP-0 -> abordagem prática: a partir do SRP-2, altera EtlProcessor adicionado um contador

OCP-1 -> alternativa usando herança; observe alterações (metodos para criaçao das dependencias) 
	  no EtlProcessor original para suportar a extensão...

OCP-2 -> alternativa usando evento; observe alterações (adição do evento) no EtlProcessor original para suportar a extensão...

OCP-3 -> alternativa usando métodos de extensão; observe alterações (Action como propriedade para validação do dado)
          no EtlProcessor original para suportar a extensão...

OCP-4 -> alternativa usando composição; observe as alterações (usando IReportAccountLoaded - strategy pattern - para relatorio da importação)
          no EtlProcessor original para suportar a extensão...  

LSP-0 -> a partir do OCP-4, é introduzido um "valor sentinela" e aplicado virtual no GetNext do CsvAccountExtrator, 
         para iniciar demonstrações

LSP-1 -> criada DerivedCsvAccountExtractor, que retorna null (dominio expandido em relação ao pai); observe a falha

LSP-2 -> demonstra CodeContracts, aplicando Contract.Ensures (pos-condição) na classe base; 
	 mostrar opções do C.C.; 

DIP-0 -> inicia usando a mesma base do SRP-2

DIP-1 -> extraidas interfaces IAccountExtractor e IAccountLoading, e aplicadas no construtor do EtlProcessor; 
          construção manual das instancias (sem uso de IoC)

DIP-2 -> criado contador através de um Decorator para um IAccountLoading (CountingAccountLoading) 

DIP-3 -> mesmo exemplo anterior, agora utilizando container, com suporte a Decorator embutido (SimpleInjector);

DIP-5 -> solução alternativa utilizando AOP (interception)